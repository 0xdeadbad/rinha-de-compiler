use crate::ast::Element;
use std::str::FromStr;
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, crate::parser::InnerError>>, filename: &str);

extern {
  type Location = usize;
  type Error = crate::parser::InnerError;
}

match {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
} else {
  _
}

pub File: crate::ast::File = {
  <s: @L> <expression:Term> <e: @R> => crate::ast::File {
    name: filename.to_string(),
    expression,
    location: crate::ast::Location::new(s, e, filename),
  },
};

IsExternal: bool = {
  "external" => true
};

Semi: std::string::String = {
  ";" => ";".to_string(),
};

Primary: crate::ast::Term = {
  "(" <Term> ")" => <>,
  <Reference> => crate::ast::Term::Reference(<>),
  <s: @L> <value:String> <e: @R> => crate::ast::Term::Str(crate::ast::Str {
    value,
    location: crate::ast::Location::new(s, e, filename),
  }),
  <s: @L> <value:Int> <e: @R> => crate::ast::Term::Int(crate::ast::Int {
    value,
    location: crate::ast::Location::new(s, e, filename),
  }),
};

Call: crate::ast::Term = {
  <s: @L> "print" "(" <value:Term> ")" <e: @R> => crate::ast::Term::Print(crate::ast::Print {
    value: Box::new(value),
    location: crate::ast::Location::new(s, e, filename),
  }),
  <s: @L> <callee:Apply> "(" <arguments:Sep<",", Term>> ")" <e: @R> =>crate::ast::Term::Call(crate::ast::Call {
    callee: Box::new(callee),
    arguments,
    location: crate::ast::Location::new(s, e, filename),
  }),
};

FactorOp: std::string::String = {
  "*" => "*".to_string(),
  "/" => "/".to_string(),
};

Factor: crate::ast::Term = {
  Apply,
  <s: @L> <value:Apply> "." <name:Reference> <e: @R> => {
    // Report the error
    errors.push(lalrpop_util::ErrorRecovery {
        dropped_tokens: vec![],
        error: lalrpop_util::ParseError::User {
            error: crate::parser::InnerError::UnsupportedRecordIndex {
                err_span: name.location.into(),
            }
        },
    });

    crate::ast::Term::Error(crate::ast::Error {
      message: format!("unsupported record indexing `{}`", name.text),
      full_text: (&input[s..e]).to_string(),
      location: crate::ast::Location::new(s, e, filename),
    })
  },
  <s: @L> <a:Apply> <op:FactorOp> <b:Factor> <e: @R> => crate::ast::Term::Binary(crate::ast::Binary {
    location: crate::ast::Location::new(s, e, filename),
    op,
    lhs: a.into(),
    rhs: b.into(),
  }),
};

ArithmeticOp: std::string::String = {
  "+" => "+".to_string(),
  "-" => "-".to_string(),
}

Arithmetic: crate::ast::Term = {
  Factor,
  <s: @L> <a:Factor> <op:ArithmeticOp> <b:Arithmetic> <e: @R> => crate::ast::Term::Binary(crate::ast::Binary {
    location: crate::ast::Location::new(s, e, filename),
    op,
    lhs: a.into(),
    rhs: b.into(),
  }),
};

LogicalOp: std::string::String = {
  "&&" => "&&".to_string(),
  "||" => "||".to_string(),
  "==" => "==".to_string(),
  "!=" => "!=".to_string(),
  ":=" => ":=".to_string(),
  "<=" => "<=".to_string(),
  ">=" => ">=".to_string(),
  "++" => "++".to_string(),
  "**" => "**".to_string(),
  "$" => "$".to_string(),
  "<" => "<".to_string(),
  ">" => ">".to_string(),
};

Logical: crate::ast::Term = {
  Arithmetic,

  <s: @L> <a:Arithmetic> <op:LogicalOp> <b:Logical> <e: @R> => crate::ast::Term::Binary(crate::ast::Binary {
    location: crate::ast::Location::new(s, e, filename),
    op,
    lhs: a.into(),
    rhs: b.into(),
  }),
};

Apply: crate::ast::Term = {
  Primary,
  Call,
};

pub Body: crate::ast::Term = {
  "{" <value:Term> "}" => value,
}

pub Term: crate::ast::Term = {
  Logical,

  <s: @L> "let" <name:Reference> "=" <value:Term> ";" <next:Term> <e: @R> => crate::ast::Term::Let(crate::ast::Let {
    name,
    value: value.into(),
    next: next.into(),
    location: crate::ast::Location::new(s, e, filename),
  }),
  <s: @L> "if" "(" <condition:Term> ")" "{" <then:Term> "}" "else" "{" <otherwise:Term> "}" <e: @R> => crate::ast::Term::If(crate::ast::If {
    condition: condition.into(),
    then: then.into(),
    otherwise: otherwise.into(),
    location: crate::ast::Location::new(s, e, filename),
  }),

  <s: @L>
  <is_external:IsExternal?> "function"
  <name:Reference> "(" <parameters:Sep<",", Reference>> ")" <body:Body?> ";"
  <next:Term>
  <e: @R> => crate::ast::Term::Fun(crate::ast::Fun {
    is_external: is_external.unwrap_or(false),
    name: name.clone(),
    parameters,
    next: next.into(),
    value: match body {
      Some(value) => Some(Box::new(value)),
      None if !is_external.unwrap_or(false) => {
        // Report the error
        errors.push(lalrpop_util::ErrorRecovery {
            dropped_tokens: vec![],
            error: lalrpop_util::ParseError::User {
                error: crate::parser::InnerError::FunctionBodyMissing {
                    err_span: name.location.clone().into(),
                }
            },
        });

        Some(Box::new(crate::ast::Term::Error(crate::ast::Error {
          message: "function body is missing".to_string(),
          full_text: (&input[s..e]).to_string(),
          location: crate::ast::Location::new(s, e, filename),
        })))
      },
      None => None,
    },
    location: crate::ast::Location::new(s, e, filename),
  }),

  <s: @L> <error:!> <e: @R> => {
    let message = error.error.to_string();

    errors.push(error);

    crate::ast::Term::Error(crate::ast::Error {
      message,
      full_text: (&input[s..e]).to_string(),
      location: crate::ast::Location::new(s, e, filename),
    })
  },
}

Int: isize = <s:r"[0123456789]+"> => isize::from_str(s).unwrap();
String: std::string::String = <text:r#""(\\\\|\\"|[^"\\])*""#> => (&text[1..text.len() - 1]).to_string();

Text: std::string::String = {
  "`" <text:LogicalOp> => text.to_string(),
  "`" <text:ArithmeticOp> => text.to_string(),
  "`" <text:FactorOp> => text.to_string(),
  <text:"_"> => text.to_string(),
  <text:r"[a-zA-Z][a-zA-Z0-9/_]*"> => text.to_string(),
}

Reference: crate::parser::Reference = {
  <s: @L> <text:Text> <e: @R> => crate::parser::Reference {
    text: text.to_string(),
    location: crate::ast::Location::new(s, e, filename),
  }
};

#[inline]
Sep<U, T>: Vec<T> = {
  <mut v:(<T> U)*> <e:T?> => match e {
    Some(e) => {
        v.push(e);
        v
    }
    None => v
  }
}
